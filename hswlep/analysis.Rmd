---
title: "Agricultural Transition: Heart of SW LEP"
author: "Robert Berry"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: yes
    toc_float: yes
    toc_depth: 4
    smooth_scroll: yes
    theme: united
    code_folding: hide
    highlight: tango
  pdf_document:
    toc: yes
    toc_depth: '4'
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE)
```
<br />
The aim of this website is to report the ongoing geospatial data analysis for the CCRI's Agricultural Transition: Heart of South West LEP project. All of the tables and plots shown on this website can also be accessed as individual files [HERE](https://connectglosac.sharepoint.com/:f:/s/ccriprojects/EkmH8fOBINtNlhpJy_J-mqIBYQEk-p6fjgTJec68p_ji6A?e=hn0WaW). The full [R programming](https://www.r-project.org/about.html) code used to perform the work is included in this report, and can be accessed by clicking on the "Code" buttons. If you are unfamiliar with R code, comments (in plain English) have been added to describe the operation of each code block, so it should be possible to follow the methodology. 

<br />

## 1. Pillar 1: County-level

This section shows the code and outputs for the analysis of Pillar 1 (P1) payments at county level (for the counties of **Cornwall**, **Devon**, **Dorset**, and **Somerset**)

<br />

### 1.1 Data import & cleaning

Import and cleaning of the CAP Payments (data source: [HERE](https://cap-payments.defra.gov.uk/Search.aspx))  

**Step 1** - Load code packages and import data
 
```{r echo=TRUE, eval=TRUE}
#> 1.1.1 Load libraries 
library(tidyverse) # data munging and analysis
library(sf) # simple features for GIS
library(qgisprocess) # access to QGIS algorithms
library(here) # relative path management for reproducibility
library(lubridate) # for date string manipulation/conversion
library(janitor) # data cleaning functions
library(knitr) # report rendering with rmarkdown
library(ggplot2) # plots and visualisations
library(readxl) # import xls
library(scales) # for plot scale customisation
library(mapproj) # map zoom coords
library(leaflet) # interactive web maps
  
#> 1.1.2 Import data (trimming white space)
#> "RPA" sheet
rpa.1 <- readxl::read_xlsx(here("In", "BPS_Glos", "2020_All_CAP_Search_Results_Data_P14.xlsx"), trim_ws = TRUE, sheet = "RPA")
#> "RPA2" sheet
rpa.2 <- readxl::read_xlsx(here("In", "BPS_Glos", "2020_All_CAP_Search_Results_Data_P14.xlsx"), trim_ws = TRUE, sheet = "RPA2")

```

**Step 2** - Data cleaning and pre-processing

```{r echo=TRUE, eval=TRUE}
#> 1.1.3 Data cleaning and pre-processing

#> Bind the two RPA tables together (they are split alphabetically by beneficiary name)
db <- rbind(rpa.1, rpa.2)

#> Remove duplicates
db <- db %>% 
  distinct()

#> Remove any empty records where all columns are "NA"
# Following filters rows with at least one column not "NA"
db <- janitor::remove_empty(db, which = "rows")

#> Select only relevant rcolumns
db <- db %>% 
  select("BeneficiaryCode", "PostcodePrefix_F202B", "TownCity_F202C", "Basic payment scheme", "Greening: practices beneficial for climate and environment") |> 
  arrange(desc(`Basic payment scheme`))


```


Table 1.1.1 Full database on import = *`r toString(nrow(db))`* records (all England)
```{r echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
#> Glimpse
glimpse(db)
```

Table 1.1.2 First 6 rows of database
```{r echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
#> Head
head(db)
```



<br />


### 1.2 Land cover processing

The CAP Payments dataset reports payments at postcode district level, but postcode districts do not conform to administrative boundaries (e.g. counties, district unitary authorities). Our approach is to calculate the area of agricultural land (using Corine land cover data) within each postcode district, and to use this to calculate the P1 payments. For districts which straddle county boundaries, the area of agricultural land both inside and outside of the target county are calculated, and the P1 payments are calculated based on the proportion of agricultural land inside the boundary. Agricultural land cover classes were extracted from the Corine 2018 land cover dataset and used for the agricultural area calculations. 

The following geospatial datasets are used for this analysis: <br />
 - County boundaries - [(OS BoundaryLine)](https://www.ordnancesurvey.co.uk/business-government/products/boundaryline) <br />
 - Postcode district areas - [(OpenDoor Postcode Districts)](https://www.opendoorlogistics.com/data/) <br />
 - Land Cover data - [(Corine 2018)](https://catalogue.ceh.ac.uk/documents/084e0bc6-e67f-4dad-9de6-0c698f60e34d) <br /> 
 
```{r echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, results='hide'}

#> Import county boundaries
#> Import ceremonial counties polygon layer from OS BoundaryLine dataset
counties.gb <- st_read(here("In", "Shape", "Counties_GB_BoundaryLine_2018.shp"))

#> Import postcode district boundary polygon data (source: https://www.opendoorlogistics.com/downloads/)
pcodes.gb <- st_read(here("In", "Shape", "Pcode_Districts_OpenDoor_2017.shp"))

#> Import CORINE 2018 land cover data (polygons)
#> Data source: https://catalogue.ceh.ac.uk/documents/084e0bc6-e67f-4dad-9de6-0c698f60e34d
corine.gb <- st_read(here("In", "Shape", "corine_2018_GB.shp"))
#> Select only agri land classes:
# 211 - Non-irrigated arable land
# 212 - Permanently irrigated land
# 213 - Rice fields
# 221 - Vineyards
# 222 - Fruit trees and berry plantations
# 223 - Olive groves
# 231 - Pastures
# 241 - Annual crops associated with permanent crops
# 242 - Complex cultivation patterns
# 243 - Land principally occupied by agriculture with significant areas of natural vegetation
# 244 - Agro-forestry areas
# 321 - Natural grasslands
agri.land.classes <- c("211", "212", "213", "221", "222", "223", "231", "241", "242", "243", "244", "321")
#> Subset data based on land cover codes
corine.agri <- corine.gb |> 
  select(ID, CODE_18) |> 
  filter(CODE_18 %in% agri.land.classes)

#> Show an example plot of agri land extracted from Corine
#> Get Cornwall boundaries
cornwall.sf <- counties.gb |> 
  filter(NAME == "Cornwall")
#> Clip corine.gb to extent of Cornwall
corine.clip <- st_intersection(corine.agri,cornwall.sf)


  
#> Export agri data for detailed visual checking in QGIS
#> Remove previous shapefile export
unlink(here("Out", "Tests", "Corine_Agri.shp"))
unlink(here("Out", "Tests", "Corine_Agri.dbf"))
unlink(here("Out", "Tests", "Corine_Agri.prj"))
unlink(here("Out", "Tests", "Corine_Agri.shx"))
st_write(corine.agri, here("Out", "Tests", "Corine_Agri.shp"))

# 
# #> Previous static map (superseded by Leaflet map)
# #> Plot
# plot0 <- ggplot(data = cornwall.sf) +
#   ggtitle("Agricultural land: Cornwall (extracted from Corine 2018)") +
#   # theme_bw() +
#   geom_sf() +
#   geom_sf(data = corine.clip, fill = "green")
# #> Render on web page
# print(plot0)

```



*Figure 1.2.1 Extent of agricultural land (derived from Corine 2018)*
```{r out.width='100%', echo=TRUE}

#> This code chunk produces an interactive leafelt map of the SW region with Corine agri land shown

#> Subset counties.gb, selecting only Cornwall (inc Isles of Scilly), Devon, Somerset, and Dorset
#> Will also use this string in Section 1.3 loop
#> Create filter string (get names first!)
counties <- c("Cornwall", "Devon", "Dorset", "Somerset")
#> Create sf object of 4 counties
south.west <- counties.gb |>
  filter(NAME %in% counties)
#> Import clipped (to SW region) dissolved layer of Corine agri
#> Pre-processed in QGIS and imported as process in R takes too long
corine.sw <- st_read(here("In", "Shape", "Corine.sw.clip.diss.shp"), quiet = TRUE)
#> Convert layers to WGS84 for use with Leaflet
south.west <- st_transform(south.west, 4326)
corine.sw <- st_transform(corine.sw, 4326)
#> Create Leaflet map
leaflet() |>
  addPolygons(data = corine.sw, fillOpacity = 0.5, color = "green", stroke = FALSE) |>
  addPolygons(data = south.west, fillOpacity = 0, label = TRUE) |>
  addTiles()

```


### 1.3 P1 reduction calculations

With all the required input data in place, P1 reductions at county level can now be computed. A brief overview of the workflow: <br />

- **Step 1**: Select the four target counties from the GB county data layer <br />
- **Step 2**: Initiate a programming loop based on the counties (i.e. same code block is run for each county in turn) <br />
- **Step 3**: Create a spatial layer of postcode districts that spatially intersect with the "active" county  <br />
- **Step 4**: Create a spatial layer of postcode districts clipped exactly to the extent of the "active" county  <br />
- **Step 5**: Create a spatial layer of postcode districts clipped exactly to the extent of the "active" county  <br />
- **Step 6**: Using the Corine data on agricultural land area (prepared in Section 1.2), calculate the agricultural land area totals for intersected postcode district polygons, and clipped postcode district polygons respectively. This gives us two values: 1) the total area of agricultural land in each postcode district, and; 2) the area of agricultural land in each postcode district that is *within* the active county  <br />
- **Step 7**: Using the agricultural land area proportions and the P1 reduction figures, calculate the "baseline" value for P1 in 2020 and following years with reductions applied up to and including 2027 <br />
- **Step 8**: Display output tables and bar plots  <br />
- **Step 9**: Export output tables and bar plots to CCRI shared drive  <br />

```{r echo=TRUE, eval=TRUE, results='asis', fig.height = 6, fig.width = 9}
#> Create filter string (get names first!)
counties <- c("Cornwall", "Devon", "Dorset", "Somerset")

#> Sequential integer counter (for figure numbers)
i <-0 

#> Initiate loop
for(active_county in counties){
  
#> Loop counter (for table caption number)
i <- i+1

#> Select target county (this will be start of loop)
county <- counties.gb |> 
  filter(NAME == active_county)

#> Select postcode district areas that intersect with active county polygon
pcodes.int <- pcodes.gb[county,]
#> Add area (km2) column
pcodes.int$AreaM2 <- st_area(pcodes.int)
#> Convert from m2 to km2
pcodes.int$AREA_KM2_TOTAL <- pcodes.int$AreaM2 / 1000000
pcodes.int$AREA_KM2_TOTAL <- round(pcodes.int$AREA_KM2_TOTAL, digits = 3)
pcodes.int$AREA_KM2_TOTAL <- as.numeric(pcodes.int$AREA_KM2_TOTAL)
#> Export data for detailed visual checking in QGIS
#> Remove existing shapefile
unlink(here("Out", "Tests", "pcodes.int.shp"))
unlink(here("Out", "Tests", "pcodes.int.dbf"))
unlink(here("Out", "Tests", "pcodes.int.prj"))
unlink(here("Out", "Tests", "pcodes.int.shx"))
st_write(pcodes.int, here("Out", "Tests", "pcodes.int.shp"), quiet = TRUE)


#> Generate a layer of clipped (cookie cutter) postcodes using active county boundary
pcodes.clip <- st_intersection(pcodes.int, county)
#> Add area (km2) column
pcodes.clip$AreaM2 <- st_area(pcodes.clip)
#> Convert from m2 to km2
pcodes.clip$AREA_KM2_CLIP<- pcodes.clip$AreaM2 / 1000000
pcodes.clip$AREA_KM2_CLIP <- round(pcodes.clip$AREA_KM2_CLIP, digits = 3)
pcodes.clip$AREA_KM2_CLIP <- as.numeric(pcodes.clip$AREA_KM2_CLIP)
#> Export data for detailed visual checking in QGIS
#> Remove existing shapefile
unlink(here("Out", "Tests", "pcodes.clip.shp"))
unlink(here("Out", "Tests", "pcodes.clip.dbf"))
unlink(here("Out", "Tests", "pcodes.clip.prj"))
unlink(here("Out", "Tests", "pcodes.clip.shx"))
st_write(pcodes.clip, here("Out", "Tests", "pcodes.clip.shp"), quiet = TRUE)


#> To calculate agri land differences for postcodes which straddle the boundary of target county...
#> 1. Intersect pcodes.int with corine.agri, to calculate area of agri land for all intersecting pcode district polys (whole polygon)
#> 2. Intersect pcodes.clip with corine.int to calculate area of agri land ony within target county polygon
#> 3. Calculate percentage difference between the TWO sets of area calculations to gove % of agri land in each pcode district polygon


#> 1. Intersect pcodes.int with corine.agri, to calculate area of agri land for all intersecting pcode district polys (whole polygon)
agri.int.total <- st_intersection(pcodes.int, corine.agri)
#> Calculate area of Corine agri land
agri.int.total$AREA_AGRI_TOTAL <- st_area(agri.int.total)
#> Convert from m2 to km2
agri.int.total$AREA_AGRI_TOTAL <- agri.int.total$AREA_AGRI_TOTAL / 1000000
agri.int.total$AREA_AGRI_TOTAL <- round(agri.int.total$AREA_AGRI_TOTAL, digits = 3)
agri.int.total$AREA_AGRI_TOTAL <- as.numeric(agri.int.total$AREA_AGRI_TOTAL)
#> Export data for detailed visual checking in QGIS
#> Remove existing shapefile
unlink(here("Out", "Tests", "agri.int.total.shp"))
unlink(here("Out", "Tests", "agri.int.total.dbf"))
unlink(here("Out", "Tests", "agri.int.total.prj"))
unlink(here("Out", "Tests", "agri.int.total.shx"))
st_write(agri.int.total, here("Out", "Tests", "agri.int.total.shp"), quiet = TRUE)
#> Create grouped (by pcode) non-geo version of the table
st_geometry(agri.int.total) <- NULL
agri.int.total <- agri.int.total |> 
  select(name, AREA_AGRI_TOTAL) |> 
  group_by(name) |> 
  summarise(AGRI_TOTAL = sum(AREA_AGRI_TOTAL))


#> 2. Intersect pcodes.clip with corine.int to calculate area of agri land ony within target county polygon
agri.int.clip <- st_intersection(pcodes.clip, corine.agri)
#> Calculate area of Corine agri land
agri.int.clip$AREA_AGRI_CLIP <- st_area(agri.int.clip)
#> Convert from m2 to km2
agri.int.clip$AREA_AGRI_CLIP <- agri.int.clip$AREA_AGRI_CLIP / 1000000
agri.int.clip$AREA_AGRI_CLIP <- round(agri.int.clip$AREA_AGRI_CLIP, digits = 3)
agri.int.clip$AREA_AGRI_CLIP <- as.numeric(agri.int.clip$AREA_AGRI_CLIP)
#> Export data for detailed visual checking in QGIS
#> Remove existing shapefile
unlink(here("Out", "Tests", "agri.int.clip.shp"))
unlink(here("Out", "Tests", "agri.int.clip.dbf"))
unlink(here("Out", "Tests", "agri.int.clip.prj"))
unlink(here("Out", "Tests", "agri.int.clip.shx"))
st_write(agri.int.clip, here("Out", "Tests", "agri.int.clip.shp"), quiet = TRUE)
#> Create grouped (by pcode) non-geo version of the table
st_geometry(agri.int.clip) <- NULL
agri.int.clip <- agri.int.clip |> 
  select(name, AREA_AGRI_CLIP) |> 
  group_by(name) |> 
  summarise(AGRI_CLIP = sum(AREA_AGRI_CLIP))


#> 3. Calculate percentage difference between the tow sets of area calculations to gove % of agri land in each pcode district polygon
#> Merge the two data frames to show size of agri area within and outside target county
agri.merge <- merge(agri.int.total, agri.int.clip, by = "name", all.x = TRUE)
#> Round area calcs up to 1 decimal place (to negate effect of small amounts of agri land being lost when clipped)
agri.merge$AGRI_TOTAL <- round(agri.merge$AGRI_TOTAL, digits = 3)
agri.merge$AGRI_CLIP <- round(agri.merge$AGRI_CLIP, digits = 2)
#> Calculate percentage of agri land within target county 
agri.merge$PCENT_AGRI_LAND <- agri.merge$AGRI_CLIP/ agri.merge$AGRI_TOTAL
#> Round up
agri.merge$PCENT_AGRI_LAND <- round(agri.merge$PCENT_AGRI_LAND, digits = 3)



#> Extract postcode districts from the BPS source data ("db") which intersect with the active county polygon boundary
#> Do this via a merge between db and pcodes.int, keeping only matching records in a new data frame
#> Rename pcodes.in and drop geom
pcodes.active <- pcodes.int
st_geometry(pcodes.active) <- NULL
BPS.merge <- merge(db, pcodes.active, by.x = "PostcodePrefix_F202B", "name", all.x = FALSE)
#> Convert all NAs to zeros in data frame
BPS.merge[is.na(BPS.merge)] <- 0



#> BPS Calcs by year

#> 2020
#> Create table with baseline P1 (BPS + Greening) payments by postcode district for 2020 (no reductions applied)
t1.2020 <- BPS.merge %>% 
  group_by(PostcodePrefix_F202B) %>% 
  summarise(P1_2020_Baseline = sum(`Basic payment scheme`) + sum(`Greening: practices beneficial for climate and environment`))
#> Check sum total of P1 for reference
sum.original.p1 <- sum(t1.2020$P1_2020_Baseline)
#> Merge with agri.merge data frame to append 2020 calcs and create new master table "t1"
t1 <- merge(t1.2020, agri.merge, by.x = "PostcodePrefix_F202B", by.y = "name")
#> #> Calculate P1 payment based on area of agri land within each postcode area
t1$P1_2020 <- t1$P1_2020_Baseline * t1$PCENT_AGRI_LAND
#> Round to 2 decimal places
t1$P1_2020 <- round(t1$P1_2020, digits = 2)



#> 2021
t1.2021 <- BPS.merge %>% 
  select(PostcodePrefix_F202B, `Basic payment scheme`, `Greening: practices beneficial for climate and environment`)
#> Column to hold total total P1 payments (i.e. BPS + Greening) - baseline for 2020
t1.2021$P1_2020 <- t1.2021$`Basic payment scheme` + t1.2021$`Greening: practices beneficial for climate and environment`
#> Add new column showing 2021 reductions
t1.2021 <- t1.2021 %>% 
  mutate(P1_2021 = case_when(P1_2020 <=30000 ~ P1_2020 * 0.95,
                              (P1_2020 >30000 & P1_2020 <=50000) ~ P1_2020 * 0.90,
                              (P1_2020 >50000 & P1_2020 <=150000) ~ P1_2020 * 0.80,
                              P1_2020 > 150000 ~ P1_2020 * 0.75))
# Group by postcode an summarise
t1.2021 <- t1.2021 %>% 
  group_by(PostcodePrefix_F202B) %>% 
  summarise(P1_2021 = sum(P1_2021))
#> Round
t1.2021$P1_2021 <- round(t1.2021$P1_2021, digits = 2)
# merge with main P1 results table (m.)
t1 <- merge(t1, t1.2021, by.x = "PostcodePrefix_F202B", by.y = "PostcodePrefix_F202B", all.x = TRUE)
# Change values according to agi land area proportion
t1$P1_2021 <- t1$P1_2021 * t1$PCENT_AGRI_LAND #> Round
t1$P1_2021 <- round(t1$P1_2021, digits = 2)
#> Check sum
sum.p1.2021 <- sum(t1$P1_2021)



#> 2022
t1.2022 <- BPS.merge %>% 
  select(PostcodePrefix_F202B, `Basic payment scheme`, `Greening: practices beneficial for climate and environment`)
#> Column to hold total total P1 payments (i.e. BPS + Greening) - baseline for 2020
t1.2022$P1_2020 <- t1.2022$`Basic payment scheme` + t1.2022$`Greening: practices beneficial for climate and environment`
#> Add new column showing 2022 reductions
t1.2022 <- t1.2022 %>% 
   mutate(P1_2022 = case_when(P1_2020<=30000 ~ P1_2020* 0.80,
                             (P1_2020>30000 & P1_2020<=50000) ~ P1_2020* 0.75,
                             (P1_2020>50000 & P1_2020<=150000) ~ P1_2020* 0.65,
                             P1_2020> 150000 ~ P1_2020* 0.60))
# Group by postcode an summarise
t1.2022 <- t1.2022 %>% 
  group_by(PostcodePrefix_F202B) %>% 
  summarise(P1_2022 = sum(P1_2022))
#> Round
t1.2022$P1_2022 <- round(t1.2022$P1_2022, digits = 2)
# merge with main P1 results table (m.)
t1 <- merge(t1, t1.2022, by.x = "PostcodePrefix_F202B", by.y = "PostcodePrefix_F202B", all.x = TRUE)
# Change values according to agi land area proportion
t1$P1_2022 <- t1$P1_2022 * t1$PCENT_AGRI_LAND #> Round
t1$P1_2022 <- round(t1$P1_2022, digits = 2)
#> Check sum
sum.p1.2022 <- sum(t1$P1_2022)


#> 2023
t1.2023 <- BPS.merge %>% 
  select(PostcodePrefix_F202B, `Basic payment scheme`, `Greening: practices beneficial for climate and environment`)
#> Column to hold total total P1 payments (i.e. BPS + Greening) - baseline for 2020
t1.2023$P1_2020 <- t1.2023$`Basic payment scheme` + t1.2023$`Greening: practices beneficial for climate and environment`
#> Add new column showing 2023 reductions
t1.2023 <- t1.2023 %>% 
  mutate(P1_2023 = case_when(P1_2020 <=30000 ~ P1_2020 * 0.65,
                             (P1_2020 >30000 & P1_2020 <=50000) ~ P1_2020 * 0.60,
                             (P1_2020 >50000 & P1_2020 <=150000) ~ P1_2020 * 0.50,
                             P1_2020 > 150000 ~ P1_2020 * 0.45))
# Group by postcode an summarise
t1.2023 <- t1.2023 %>% 
  group_by(PostcodePrefix_F202B) %>% 
  summarise(P1_2023 = sum(P1_2023))
#> Round
t1.2023$P1_2023 <- round(t1.2023$P1_2023, digits = 2)
# merge with main P1 results table (m.)
t1 <- merge(t1, t1.2023, by.x = "PostcodePrefix_F202B", by.y = "PostcodePrefix_F202B", all.x = TRUE)
# Change values according to agi land area proportion
t1$P1_2023 <- t1$P1_2023 * t1$PCENT_AGRI_LAND #> Round
t1$P1_2023 <- round(t1$P1_2023, digits = 2)
#> Check sum
sum.p1.2023 <- sum(t1$P1_2023)


#> 2024
t1.2024 <- BPS.merge %>% 
  select(PostcodePrefix_F202B, `Basic payment scheme`, `Greening: practices beneficial for climate and environment`)
#> Column to hold total total P1 payments (i.e. BPS + Greening) - baseline for 2020
t1.2024$P1_2020 <- t1.2024$`Basic payment scheme` + t1.2024$`Greening: practices beneficial for climate and environment`
#> Add new column showing 2024 reductions
t1.2024 <- t1.2024 %>% 
  mutate(P1_2024 = case_when(P1_2020 <=30000 ~ P1_2020 * 0.50,
                             (P1_2020 >30000 & P1_2020 <=50000) ~ P1_2020 * 0.45,
                             (P1_2020 >50000 & P1_2020 <=150000) ~ P1_2020 * 0.35,
                             P1_2020 > 150000 ~ P1_2020 * 0.30))
# Group by postcode an summarise
t1.2024 <- t1.2024 %>% 
  group_by(PostcodePrefix_F202B) %>% 
  summarise(P1_2024 = sum(P1_2024))
#> Round
t1.2024$P1_2024 <- round(t1.2024$P1_2024, digits = 2)
# merge with main P1 results table (m.)
t1 <- merge(t1, t1.2024, by.x = "PostcodePrefix_F202B", by.y = "PostcodePrefix_F202B", all.x = TRUE)
# Change values according to agi land area proportion
t1$P1_2024 <- t1$P1_2024 * t1$PCENT_AGRI_LAND #> Round
t1$P1_2024 <- round(t1$P1_2024, digits = 2)
#> Check sum
sum.p1.2024 <- sum(t1$P1_2024)


#> 2025
t1.2025 <- BPS.merge %>% 
  select(PostcodePrefix_F202B, `Basic payment scheme`, `Greening: practices beneficial for climate and environment`)
#> Column to hold total total P1 payments (i.e. BPS + Greening) - baseline for 2020
t1.2025$P1_2020 <- t1.2025$`Basic payment scheme` + t1.2025$`Greening: practices beneficial for climate and environment`
#> Add new column showing 2025 reductions
t1.2025 <- t1.2025 %>% 
 mutate(P1_2025 = case_when(P1_2020 <=30000 ~ P1_2020 * 0.40,
                             (P1_2020 >30000 & P1_2020 <=50000) ~ P1_2020 * 0.35,
                             (P1_2020 >50000 & P1_2020 <=150000) ~ P1_2020 * 0.25,
                             P1_2020 > 150000 ~ P1_2020 * 0.20))
# Group by postcode an summarise
t1.2025 <- t1.2025 %>% 
  group_by(PostcodePrefix_F202B) %>% 
  summarise(P1_2025 = sum(P1_2025))
#> Round
t1.2025$P1_2025 <- round(t1.2025$P1_2025, digits = 2)
# merge with main P1 results table (m.)
t1 <- merge(t1, t1.2025, by.x = "PostcodePrefix_F202B", by.y = "PostcodePrefix_F202B", all.x = TRUE)
# Change values according to agi land area proportion
t1$P1_2025 <- t1$P1_2025 * t1$PCENT_AGRI_LAND #> Round
t1$P1_2025 <- round(t1$P1_2025, digits = 2)
#> Check sum
sum.p1.2025 <- sum(t1$P1_2025)


#> 2026
t1.2026 <- BPS.merge %>% 
  select(PostcodePrefix_F202B, `Basic payment scheme`, `Greening: practices beneficial for climate and environment`)
#> Column to hold total total P1 payments (i.e. BPS + Greening) - baseline for 2020
t1.2026$P1_2020 <- t1.2026$`Basic payment scheme` + t1.2026$`Greening: practices beneficial for climate and environment`
#> Add new column showing 2026 reductions
t1.2026 <- t1.2026 %>% 
  mutate(P1_2026 = case_when(P1_2020 <=30000 ~ P1_2020 * 0.25,
                             (P1_2020 >30000 & P1_2020 <=50000) ~ P1_2020 * 0.25,
                             (P1_2020 >50000 & P1_2020 <=150000) ~ P1_2020 * 0.15,
                             P1_2020 > 150000 ~ P1_2020 * 0.15))
# Group by postcode an summarise
t1.2026 <- t1.2026 %>% 
  group_by(PostcodePrefix_F202B) %>% 
  summarise(P1_2026 = sum(P1_2026))
#> Round
t1.2026$P1_2026 <- round(t1.2026$P1_2026, digits = 2)
# merge with main P1 results table (m.)
t1 <- merge(t1, t1.2026, by.x = "PostcodePrefix_F202B", by.y = "PostcodePrefix_F202B", all.x = TRUE)
# Change values according to agi land area proportion
t1$P1_2026 <- t1$P1_2026 * t1$PCENT_AGRI_LAND #> Round
t1$P1_2026 <- round(t1$P1_2026, digits = 2)
#> Check sum
sum.p1.2026 <- sum(t1$P1_2026)


#> 2027
t1.2027 <- BPS.merge %>% 
  select(PostcodePrefix_F202B, `Basic payment scheme`, `Greening: practices beneficial for climate and environment`)
#> Column to hold total total P1 payments (i.e. BPS + Greening) - baseline for 2020
t1.2027$P1_2020 <- t1.2027$`Basic payment scheme` + t1.2027$`Greening: practices beneficial for climate and environment`
#> Add new column showing 2027 reductions
t1.2027 <- t1.2027 %>% 
   mutate(P1_2027 = case_when(P1_2020<=30000 ~ P1_2020* 0.15,
                             (P1_2020>30000 & P1_2020<=50000) ~ P1_2020* 0.15,
                             (P1_2020>50000 & P1_2020<=150000) ~ P1_2020* 0.10,
                             P1_2020> 150000 ~ P1_2020* 0.10))
# Group by postcode an summarise
t1.2027 <- t1.2027 %>% 
  group_by(PostcodePrefix_F202B) %>% 
  summarise(P1_2027 = sum(P1_2027))
#> Round
t1.2027$P1_2027 <- round(t1.2027$P1_2027, digits = 2)
# merge with main P1 results table (m.)
t1 <- merge(t1, t1.2027, by.x = "PostcodePrefix_F202B", by.y = "PostcodePrefix_F202B", all.x = TRUE)
# Change values according to agi land area proportion
t1$P1_2027 <- t1$P1_2027 * t1$PCENT_AGRI_LAND #> Round
t1$P1_2027 <- round(t1$P1_2027, digits = 2)
#> Check sum
sum.p1.2027 <- sum(t1$P1_2027)

#> Convert all NAs to zeros in data frame
t1[is.na(t1)] <- 0



#> Create plot

#> P1 payments by year
p1.in <- as.data.frame(colSums(t1[6:13]))
#> Change rownames to column "Value"
p1.plot <- tibble::rownames_to_column(p1.in, "VALUE")
#> Extract year from string
p1.plot$VALUE <- sub("^.*([0-9]{4}).*", "\\1", p1.plot$VALUE)
names(p1.plot)[1]<-paste("Year")
names(p1.plot)[2]<-paste("Value_bps")

#> Print table t1 on web page
print(knitr::kable(t1, col.names = c("PC", "2020_Unadjusted", "Agri_In", "Agri_Out", "Agri_PC", "2020", "2021", "2022", "2023", "2024", "2025", "2026", "2027"), caption = paste0("Table 1.", i , " ", "P1 reductions by postcode district - ",  active_county)))

#> Add line breaks
cat("\n")
cat("\n")
cat("\n")
cat("\n")
cat("\n")
cat("\n")


# Simple bar chart
plot1 <- ggplot(p1.plot, aes(x=Year, y=Value_bps)) + 
  theme_bw() +
  geom_bar(stat = "identity", fill="#2c66b8", width = 0.6) +
  geom_text(aes(label= paste0(round(Value_bps / 1000000, digits = 1), " M")), vjust = 1.5, colour = "white") +
  labs(title = paste0("Pillar 1 reductions:", " ", active_county), x = "Year", y = "Value (Â£)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(axis.title.y = element_text(margin = margin(t = 0, r = 16, b = 0, l = 0))) +
  theme(axis.title.x = element_text(margin = margin(t = 12, r = 0, b = 0, l = 0))) +
  theme(legend.position="none") +
  scale_y_continuous(labels = scales::unit_format(unit = "M", scale = 1e-6))
plot1

#> Add line breaks
cat("\n")
cat("\n")
cat("\n")
cat("\n")
cat("\n")
cat("\n")

#> Render on web page
print(plot1)

#> Export the plot
ggsave(here("Out", "P1", "County", "Plot", paste0("P1_Reductions_", active_county, ".png")))

#> Export final t1 table
write_csv(t1, here("Out", "P1", "County", "CSV", paste0("P1_Reductions_", active_county, ".csv")))

}
          

```







## To do


## 2. Pillar 1: District-level

Calculation of P1 payment reductions at sub-county (district unitary authority) level

```{r echo=TRUE, eval=TRUE, results='asis', fig.height = 6, fig.width = 9}

#> Get district boundary data






```


*NTS - clip the districts to county boundary*

## 3. Agri-Environment 


## 4. Agri land proportions calcs

Summary of Corine land cover types (all) by:

- County level 

- District level

- Agri land classification areas / maps
- Summary ofAll CORINE types




